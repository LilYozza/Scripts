--Essential Function Script
local startTime = os.clock()

-->Services<--
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local TeamsService = game:GetService("Teams")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local HttpService = game:GetService("HttpService")
local httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
local TeleportService = game:GetService("TeleportService")

-->Base Variables<--
local VbaseTable = {"root", "base"} -- Names to Match to get Vehicle Root
local Player = Players.LocalPlayer

local Mouse = Player:GetMouse()
local Camera = workspace.CurrentCamera

-- Mouse Click Signals
local Signals = {'MouseButton1Down','MouseButton1Up', 'MouseButton1Click', 'Activated'}

local _sHelp = {

    ["Touch"] = "Touch(PartWithTouchTransmittter, PartToTouchIt, TimeToWaitAfter)",
    ["MoveTo"] = "MoveTo(PartToMoveTo, Offset, TeleportBack?, TimeToWaitBeforeTeleportBack, Function, FunctionWaitTime)",
    ["GetHrp"] = "GetHrp(Player)",
    ["GetPos"] = "GetPos(Player)",
    ["ChangeCollide"] = "ChangeCollide(Part, Toggle?)",
    ["MovePart"] = "MovePart(Part, Location, Offset, TimeToWaitPerPart)",
    ["RemovePart"] = "RemovePart(Part(Can Be Table / Part))",
    ["SortTableByNumber"] = "SortTableByNumber(Table)",
    ["SortTableByName"] = "SortTableByName(Table)",
    ["SortTableByDistance"] = "SortTableByDistance(Table, Part)",
    ["RemoveFromTable"] = "RemoveFromTable(Table, Item)",
    ["PrintTable"] = "PrintTable(Table)",
    ["GetElementFromDictionary"] = "GetElementFromDictionary(Table, Element)",
    ["GetPositionFromTable"] = "GetPositionFromTable(Table, Object)",
    ["SendKey"] = "SendKey(Key)",
    ["SendClick"] = "SendClick(GUIButton)",
    ["fromSuffixString"] = "fromSuffixString(Value, Table(Suffixes))",
    ["NextTeam"] = "NextTeam(Player, Table)",
    ["PrevTeam"] = "PrevTeam(Player, Table)",
    ["GetDistance"] = "GetDistance(Object1, Object2)",
    ["TweenPart"] = "TweenPart(Part, Destination, Speed, Style)",
    ["GetDisplayNames"] = "GetDisplayNames(Bool?(ReturnPlayer Or Not))",
    ["GetPlayerByDisplayName"] = "GetPlayerByDisplayName(Player)",
    ["GetClosestPart"] = "GetClosestPart(Table, Part)",
    ["FindInTable"] = "FindInTable(Table, Item)",
    ["MatchTable"] = "MatchTable(Table, Item)",
    ["ReverseTable"] = "ReverseTable(Table)",
    ["ReturnTableAsString"] = "ReturnTableAsString(Table)",
    ["Timer"] = "Timer(Time(seconds))",
    ["PathFind"] = "PathFind(Part, Color) - STILL IN WIP",
    ["MakePath"] = "MakePath(Part, Color) - STILL IN WIP",
    ["CreateTextLabel"] = "CreateTextLabel(Text, Color, Position)",
    ["CreateBillBoard"] = "CreateBillBoard()",
    ["Tag"] = "Tag(Part, Bool?(Add OR Remove), Settings1, Settings2)",
    ["FindItem"] = "FindItem(Name, PartOrNot, MatchType)",
    ["Repeat"] = "Repeat(Function, Bool, Timeout)",
    ["GetMousePlayer"] = "GetMousePlayer() - Returns Player Closest To Mouse",
    ["ExportScripts"] = "ExportScripts(_instance, _folderName)",
}


-->FUNCTIONS TO ADD<--
-->Remove From Table (READY TO TEST)

local function getPosition(input)
    if typeof(input) == "CFrame" then
        return input.Position
    elseif typeof(input) == "Vector3" then
        return input
    elseif typeof(input) == "Instance" and input:IsA("BasePart") then
        return input.Position
    end
    return nil
end

--> Non Return Functions <--
getgenv().Touch = function(_touchPart, _basePart, _timeout)
	if _basePart and typeof(_basePart) == "number" then 
		_timeout = _basePart 
		_basePart = nil
	end
    _basePart = _basePart or Player.Character and Player.Character:WaitForChild("HumanoidRootPart")
	if _basePart and _touchPart and _touchPart:IsA("BasePart") and _basePart:IsA("BasePart") then
		firetouchinterest(_basePart, _touchPart, 0)
		firetouchinterest(_basePart, _touchPart, 1)
	else
		warn("Touch: Bad Values...")
	end
	task.wait(_timeout)
end

--Add Angles
getgenv().MoveTo = function(_basePart, _offset, _back, _backTime, _func, _funcWait)
    local oldPos
    if _back then
        oldPos = Player.Character:WaitForChild("HumanoidRootPart").CFrame
    end
	if not _offset or typeof(_offset) ~= "Vector3" then
		_offset = Vector3.new(0,0,0)
	end
	if _basePart then
        if typeof(_basePart) == "CFrame"  then
		    Player.Character:SetPrimaryPartCFrame(_basePart + _offset)
        elseif typeof(_basePart) == "Vector3" then
            Player.Character:SetPrimaryPartCFrame(CFrame.new(_basePart + _offset))
        elseif _basePart:IsA("BasePart") then
            Player.Character:SetPrimaryPartCFrame(_basePart.CFrame + _offset)
        end
        if _func and type(_func) == "function" then
            _func()
            if _funcWait then
                task.wait(_funcWait)
            end
        end
        if oldPos and _back then
            task.wait(_backTime)
           Player.Character:SetPrimaryPartCFrame(oldPos)
        end
	else
		warn("MoveTo: Bad Values...")
	end
end

getgenv().GetHrp = function(_player) -- Returns HumanoidRootPart
    if not _player then _player = Player end
    local hrp = _player.Character:WaitForChild("HumanoidRootPart")
    if hrp then 
        return hrp
    else 
        warn("Couldnt Find HumanoidRootPart")
    end
end

getgenv().GetPos = function() -- Returns CFrame Where it can be used as .Position
    if not _player then _player = Player end
    local hrp = _player.Character:WaitForChild("HumanoidRootPart")
    if hrp then 
        return hrp.CFrame
    else 
        warn("Couldnt Find HumanoidRootPart")
    end
end

getgenv().ChangeCollide = function(_tbl, _bool)
	if _tbl then
		if typeof(_tbl) == "table" then
			for _,v in pairs(workspace:GetDescendants())do
				if table.find(_tbl, v.Name) or table.find(_tbl, v)then
					if v:IsA("BasePart") then
						v.CanCollide = _bool
					end
					for __,_v in pairs(v:GetDescendants())do
						if _v:IsA("BasePart") then
							_v.CanCollide = _bool
						end
					end
				end
			end
		elseif typeof(_tbl) == "Instance" then
			if _tbl:IsA("BasePart") then
				_tbl.CanCollide = _bool
			end
			for _,v in pairs(_tbl:GetDescendants())do
				if v:IsA("BasePart") then v.CanCollide = _bool end
			end
		end

	else
		warn("ChangeCollide: Bad Values...")
	end
end

getgenv().MovePart = function(_part, _location, _offset, _timeout)
	if _part and _location and _location:IsA("BasePart") then
		if not _offset or typeof(_offset) ~= "Vector3" then 
			_offset = Vector3.new(0,0,0)
		end
		if typeof(_part) == "table" and _part[1] then
			if typeof(_part[1]) == "Instance" then
				for _,v in pairs(_part)do
					if v:IsA("BasePart") then
						v.CFrame = _location.CFrame + _offset
						task.wait(_timeout)
					end
				end
			elseif typeof(_part[1] == "String") then
				for _,v in pairs(workspace:GetDescendants())do
					if table.find(_part, v.Name) and v:IsA("BasePart") then
						v.CFrame = _location.CFrame + _offset
						task.wait(_timeout)
					end
				end
			end
		elseif typeof(_part) == "Instance"  then
			if _part:IsA("BasePart") then
				_part.CFrame = _location.CFrame + _offset
			end
			for _,v in pairs(_part:GetDescendants())do
				if v:IsA("BasePart") then
					v.CFrame = _location.CFrame + _offset
				end
			end
		end

	else
		warn("MovePart: Bad Values...")
	end
end

getgenv().RemovePart = function(_part)
	if _part then
		if typeof(_part) == "table" and _part[1] then
			if typeof(_part[1]) == "Instance" then
				for _,v in pairs(_part)do
					v:Destroy()
				end
			elseif typeof(_part[1]) == "string" then
				for _,v in pairs(workspace:GetDescendants())do
					if table.find(_part, v.Name) then
						v:Destroy()
					end
				end
			end
		elseif typeof(_part) == "string" then
			for _,v in pairs(workspace:GetDescendants())do
				if v.Name == _part then
					v:Destroy()
				end
			end
		end
	else
		warn("RemovePart: Bad Values...")
	end
end

getgenv().SortTableByNumber = function(_tbl) -- ONLY ACCEPTS TABLES WITH .NAME PROPERTY ATM
    table.sort(_tbl, function(a, b)
        local numA = tonumber(a.Name:match("%d+$")) or 0
        local numB = tonumber(b.Name:match("%d+$")) or 0
        return numA < numB
    end)
    return _tbl
end

getgenv().SortTableByName = function(_tbl) -- ONLY ACCEPTS TABLES WITH .NAME PROPERTY ATM
    table.sort(_tbl, function(a, b)
        return a.Name < b.Name
    end)
    return _tbl
end

getgenv().SortTableByDistance = function(_tbl, _part)
    if _tbl and typeof(_tbl) == "table" then
        _part = _part or Player.Character:WaitForChild("HumanoidRootPart")
        table.sort(_tbl, function(a, b)
            return (a.Position - _part.Position).Magnitude < (b.Position - _part.Position).Magnitude
        end)
        return _tbl
    else
        warn("SortTableByDistance: Is Nil or Not a Table")
    end
end

getgenv().RemoveFromTable = function(_tbl, _item)
	if _tbl and typeof(_tbl) == "table" then
		for _,v in pairs(_tbl)do
			if typeof(v) == "Instance" then
				if v.Name == _item or v == _item then
					table.remove(_tbl, _)
				end
			elseif typeof(v) == "string" then
				if v == _item then
					table.remove(_tbl, _)
				end
			end
		end
	else
		warn("RemoveFromTable: Bad Values")
	end
end

getgenv().PrintTable = function(_tbl, indent)
    indent = indent or ""
    
    if _tbl and typeof(_tbl) == "table" then
        for k, v in pairs(_tbl) do
            if typeof(v) == "table" then
                print(indent .. tostring(k) .. " = {")
                PrintTable(v, indent .. "  ")
                print(indent .. "}")
            else
                print(indent .. tostring(k) .. " = " .. tostring(v))
            end
        end
    else
        warn("PrintTable: Bad Values")
    end
end

getgenv().GetElementFromDictionary = function(_tbl, index)
    if _tbl and typeof(_tbl) == "table" then
        local count = 1
        index = index or count
        for _,v in pairs(_tbl) do
            if count == index or _ == index then return v end
            count = count + 1
        end
        return nil  -- Return nil if index is out of range
    else
        warn("GetElementFromDictionary: Table is nil or not a Table")
    end
end

getgenv().GetPositionFromTable = function(_tbl, value)
    if _tbl and typeof(_tbl) == "table" then
        for i, v in pairs(_tbl) do
            if v == value then
                return i  -- Return the index (position) of the matching element
            end
        end
        return nil  -- Return nil if the value is not found
    else
        warn("GetPositionFromTable: Table is nil or not a Table")
    end
end

getgenv().SendKey = function(_key)
	if _key then
		VirtualInputManager:SendKeyEvent(true, _key, false, game)
	else
		warn("SendKey: Bad Values")
	end
end

getgenv().SendClick = function(_button)
	if _button then
        for i,v in pairs(Signals) do
            firesignal(_button[v])
        end
	else
		warn("SendClick: Bad Values")
	end
end

--> Return Functions <--
getgenv().fromSuffixString = function(_value, _suffixes)
    if _value then
        if not _suffixes then
            _suffixes = {"K", "M", "B", "T", "Q"}
        end

        -- Handle TextLabel
        if typeof(_value) == Instance and _value:IsA("TextLabel") then
            _value = _value.Text
        end

        -- Handle numeric values
        if typeof(_value) == "number" or tonumber(_value) then
            return tonumber(_value)
        end

        -- Handle edge cases for "0" or empty strings
        if _value == "0" or _value == "" then
            return 0
        end

        _value = _value:upper()

        -- Check for suffix
        for _, suffix in ipairs(_suffixes) do
            if _value:match(suffix) then
                -- Extract number and suffix
                local n, foundSuffix = string.match(_value, "([%d%.]+)(%a)")
                if n and foundSuffix and foundSuffix == suffix then
                    local i = table.find(_suffixes, foundSuffix) or 0
                    return tonumber(n) * math.pow(10, i * 3)
                end
            end
        end

        -- If no suffix is found, remove non-numeric characters
        _value = _value:gsub("[^%d%.]", "")
        return tonumber(_value)
    else
        warn("fromSuffixString: Bad Values...")
    end
end


getgenv().NextTeam = function(_player, _sortedTbl)
	if not _player then _player = Player end
	if not _sortedTbl then _sortedTbl = TeamsService:GetTeams() end
	
	local curr = _player.Team
	if curr then
		for _,v in pairs(_sortedTbl) do
			if curr == v and _sortedTbl[_+1] then
				return _sortedTbl[_+1]
			end
		end
	else
		warn("NextTeam: Player Does Not Have A Team")
	end
end

getgenv().PrevTeam = function(_player, _sortedTbl)
	if not _player then _player = Player end
	if not _sortedTbl then _sortedTbl = TeamsService:GetTeams() end

	local curr = _player.Team
	if curr then
		for _,v in pairs(_sortedTbl) do
			if curr == v and _sortedTbl[_-1] then
				return _sortedTbl[_-1]
			end
		end
	else
		warn("PrevTeam: Player Does Not Have A Team")
	end
end

getgenv().GetDistance = function(_p1, _p2)
    _p2 = _p2 or (Player.Character and Player.Character.PrimaryPart) or false

    if _p1 and ((typeof(_p1) == "Instance" and _p1:IsA("BasePart")) or typeof(_p1) == "CFrame" or typeof(_p1) == "Vector3") then
        if _p2 and ((typeof(_p2) == "Instance" and _p2:IsA("BasePart")) or typeof(_p2) == "CFrame" or typeof(_p2) == "Vector3") then
            local pos1 = getPosition(_p1)
            local pos2 = getPosition(_p2)
            
            return (pos1 - pos2).Magnitude
        else
            warn("GetDistance: _p2 has no Position...")
            return
        end
    else
        warn("GetDistance: _p1 has no Position...")
        return
    end
end

getgenv().TweenPart = function(_des, _part, _speed, _style)
    _part = (Player.Character and Player.Character.PrimaryPart) or false
	if _part and _des and _part:IsA("BasePart") then
		if typeof(_des) == "Instance" and _des:IsA("BasePart") then
			_des = _des.CFrame
		elseif typeof(_des) == "Vector3" then
			_des = CFrame.new(_des)
		end
		if not _speed or typeof(_speed) ~= "number" then _speed = 1 end
		if not _style then _style = Enum.EasingStyle.Linear end
		local _tween = TweenService:Create(_part, TweenInfo.new(_speed, _style), {CFrame = _des})
		_tween:Play()
		return _tween
	else
		warn("TweenPart: Bad Values...")
	end
end

getgenv().GetDisplayNames = function(_bool) --_bool is to return localplayer also or not (false to not return)
	local _t = {}
    if _bool == nil then _bool = true end
	for _,v in pairs(Players:GetPlayers())do
        if _bool or v ~= Player then
		    table.insert(_t, v.DisplayName)
        end
	end
	return _t
end

getgenv().GetPlayerByDisplayName = function(_displayName)
	if _displayName and typeof(_displayName) == "string"then
		for _,v in pairs(Players:GetPlayers())do
			if v.DisplayName == _displayName then
				return v
			end
		end
	else
		warn("GetPlayerByDisplayName: Bad Values...")
	end
end

getgenv().GetClosestPart = function(_tbl, _part)
    _part = _part or Player.Character:WaitForChild("HumanoidRootPart")
	if _tbl and typeof(_tbl) == "table" and _part:IsA("BasePart") then
		local _s
		local _min = math.huge
		for _,v in pairs(_tbl)do
			if v:IsA("BasePart") or v:IsA("CFrame") then
				local _dis = GetDistance(_part, v)
				if _dis and _dis < _min then
                    _min = _dis
					_s = v
				end
			else
				warn("GetClosestPart: Index: ".._.." Has no Position/CFrame")
			end
		end
		if _s then
			return _s
		else
			warn("GetClosestPart: No Part Was Found")
		end
	else
		warn("GetClosestPart: Bad Values...")
	end
end

getgenv().FindInTable = function(_tbl, _item)
	if _tbl and typeof(_tbl) == "table" and _item and typeof(_item) == "string" then
		for _,v in pairs(_tbl)do
			if v.Name == _item or _ == _item then
				return v
			end
		end
	else
		warn("FindInTable: Bad Values...")
	end
end

getgenv().MatchTable = function(_tbl, _item)
    if _tbl and typeof(_tbl) == "table" then
        for _,v in pairs(_tbl) do
            local n = v.Name or v
            if _item:match(n) then return v end
        end
    else
        warn("MatchTable: Bad Values...(Table nil or not a Table)")
    end
end

getgenv().ReverseTable = function(_tbl)
	if _tbl and typeof(_tbl) == "table" then
		local newTable = {}
		for _,v in pairs(_tbl) do
			newTable[#_tbl+1 - _] = _tbl[_]
		end
		return newTable
	else
		warn("ReverseTable: Bad Values...")
	end
end

getgenv().ReturnTableAsString = function(_tbl)
	if _tbl and typeof(_tbl) == "table" then
		return table.concat(_tbl, ", ")
	else
		warn("ReturnTableAsString: Bad Values...")
	end
end

getgenv().Timer = function(_time)
	if _time then
		if typeof(_time) == "number" or tonumber(_time) then
			task.wait(_time) return true
		end
	else
		warn("Timer: Bad Values...")
	end
end

getgenv().CreateTextLabel = function(text, color, position)

    if not text then text = "" end
    if not color then color = Color3.fromRGB(0,255,0) end
    if not position then position = UDim2.new(0,0,0,0) end
	-- Creates Name Tag --
	local newText = Instance.new("TextLabel")
	-- Data --
	newText.Size = UDim2.new(1,0,0.3,0)
	newText.Position = position
	newText.BackgroundTransparency = 1
	--newText.TextScaled = true

	-- Text --
    newText.Text = text
	newText.TextSize = 13
	newText.Font = Enum.Font.Legacy
	newText.TextColor3 = color

    return newText
end

getgenv().CreateBillBoard = function()
    local _defaultBillBoard = Instance.new("BillboardGui")
    _defaultBillBoard.Name = "Tag"
    _defaultBillBoard.AlwaysOnTop = true
    _defaultBillBoard.Size = UDim2.new(0, 250,0, 100)
    _defaultBillBoard.ExtentsOffset = Vector3.new(0,1,0)

    return _defaultBillBoard
end

local _RenderCon = {}
getgenv().Tag = function(_p, _b, _text, _s1, _s2) --_p = Part / _b = true or false to add / remove / _s = Override Tag Properties
    if _p and _p:IsA("BasePart") then
        if _b == nil then _b = true end

        local _check = _p:FindFirstChild("Tag")
        if _b == true then
            if _check then _check:Destroy() end
            if not _text then _text = _p.Name end
            if not _s1 then _s1 = getgenv().CreateBillBoard() end
            if not _s2 then _s2 = getgenv().CreateTextLabel(_text) end

            _s2.Parent = _s1
            _s1.Parent = _p

            _RenderCon[_p] = RunService.Heartbeat:Connect(function(deltaTime)
                if _p then
                    _s2.Text = _text .. " [" .. math.ceil(GetDistance(_p)) .. "]"
                end
            end)
            

            return {_p, _s1, _s2}
        else
            if _RenderCon[_p] then 
                _RenderCon[_p]:Disconnect()
                _RenderCon[_p] = nil
            end
            if _check then _check:Destroy() end
        end
    else
        warn("Tag: Bad Values...(Part(1))")
    end
end

getgenv().FindItem = function(_s, _p, _t) -- _s = String to find / _p = item to search in / _t = exact match or not
    if _s and typeof(_s) == "string" then
        if _t == nil then _t = true end
        local _tb = {}
        if _p then
            for _,v in pairs(_p:GetDescendants())do
                if not _t and string.find(v.Name, _s) then table.insert(_tb, v) end
                if _t and v.Name == _s then table.insert(_tb, v) end
            end
        else
            for _,v in pairs(game.Workspace:GetDescendants())do
                if not _t and string.find(v.Name, _s) then table.insert(_tb, v) end
                if _t and v.Name == _s then table.insert(_tb, v) end
            end
        end
        return _tb
    else
        warn("FindItem: Bad Values...(No String To Search)")
    end
end

getgenv().Repeat = function(_func, _bool, _timeout, _checkSpeed) -- WIP
    if _func and typeof(_func) == "function" then
        _bool = _bool or false
        _timeout = _timeout or 10
        _checkSpeed = _checkSpeed or 0.1


        local timer = true
        spawn(function() task.wait(_timeout) timer = false end)
        repeat _func() task.wait(_checkSpeed) until _bool or not timer
    else
        warn("Repeat: Bad Values...(Function nil or not a Function)")
    end
end

getgenv().GetMousePlayer = function()
	local Closest = {nil, nil}
	local MousePos = Vector2.new(Mouse.X, Mouse.Y)
	for _, Player in pairs(game.Players:GetPlayers()) do
		if Player == game.Players.LocalPlayer then continue end
		local Character = Player.Character
		if Character then
			local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
			if HumanoidRootPart then
				local vector, onScreen = Camera:WorldToScreenPoint(HumanoidRootPart.Position)
				if onScreen then
					local Distance = (MousePos - Vector2.new(vector.X, vector.Y)).Magnitude
					if Closest[1] == nil then Closest = {Player, Distance} continue end
					if  Distance < Closest[2] then
						Closest = {Player, Distance}
					end
				end
			end
		end
	end
	return table.unpack(Closest)
end

getgenv().ExportScripts = function(_instance, _folderName)
    _folderName = _folderName or "Output"
    if (not _instance and not typeof(_instance) == "Instance") or isfolder(_folderName) then warn("exportScripts: Bad Values...") return end
    for _, v in ipairs(_instance:GetDescendants()) do
        if v:IsA("Script") or v:IsA("LocalScript") or v:IsA("ModuleScript") then

            local relativePath = v:GetFullName():gsub("^".._instance:GetFullName(), ""):gsub("%.", "/")
            local filePath = _folderName .. "/" .. relativePath .. ".lua"

            local folderPath = filePath:match("(.+)/[^/]+%.lua$")
            if folderPath then
                if not isfolder(folderPath) then
                    makefolder(folderPath)
                end
            end

            local code = decompile(v)
            writefile(filePath, code)
        end
    end
end


getgenv().GetVehicle = function(_player, _name)
    _player = _player or Player
    if _name and not table.find(VbaseTable, _name:lower()) then table.insert(VbaseTable, _name:lower()) end
    local hum = _player and _player.Character and _player.Character:WaitForChild("Humanoid", 5)
    if hum then
        local model = hum.SeatPart and hum.SeatPart:FindFirstAncestorOfClass("Model")
        if model then
            if model.PrimaryPart then return model.PrimaryPart end
            for _, part in ipairs(model:GetDescendants()) do
                if part:IsA("BasePart") and not part:IsA("Seat") and MatchTable(VbaseTable, part.Name:lower()) then
                    return part
                end
            end
        end
    else
        warn("GetVehicle: Couldnt Find Character")
    end
end

getgenv().GetVehicleModel = function(_player, _name)
    _player = _player or Player
    if _name and not table.find(VbaseTable, _name:lower()) then table.insert(VbaseTable, _name:lower()) end
    local hum = _player and _player.Character and _player.Character:WaitForChild("Humanoid", 5)
    if hum then
        local model = hum.SeatPart and hum.SeatPart:FindFirstAncestorOfClass("Model")
        if model then
            return model
        end
    end
end

getgenv().EHelp = function(_func)
    for _,v in pairs(_sHelp) do
        if _func and string.find(_, _func) then
            print(_,":",v)
        elseif not _func then
            print(_,":",v)
        end
    end
end

getgenv().NewServer = function()
    if httprequest then
        local servers = {}
        local req = httprequest({Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", game.PlaceId)})
        local body = HttpService:JSONDecode(req.Body)

        if body and body.data then
            for i, v in next, body.data do
                if type(v) == "table" and tonumber(v.playing) and tonumber(v.maxPlayers) and v.playing < v.maxPlayers and v.id ~= game.JobId then
                    table.insert(servers, 1, v.id)
                end
            end
        end

        if #servers > 0 then
            TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], Player)
        else
            return notify("Serverhop", "Couldn't find a server.")
        end
    else
        notify("Incompatible Exploit", "Your exploit does not support this command (missing request)")
    end    
end

getgenv().EFLoaded = true
print(string.format("Loaded Functions in: %.6f seconds", os.clock() - startTime))
