-- Requires EssentialFunctions
--[[
    To Do




]]--

local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local PFisRunning = false
local rootFolder = Workspace:FindFirstChild("PathVisuals")
if not rootFolder then
    rootFolder = Instance.new("Folder")
    rootFolder.Parent = Workspace
    rootFolder.Name = "PathVisuals"
end


local function cleanFolder(_folder)
    if _folder then
        for _,v in pairs(_folder:GetChildren())do
            v:Destroy()
        end
    end
end

local function removeFolder(_folder)
    if _folder then
        _folder:Destroy()
    end
end

local function checkForWall(_hrp, _direction, _distance)
    _direction = _direction or _hrp.CFrame.LookVector
    _distance = _distance or 10
    local origin = _hrp.Position + _hrp.CFrame.LookVector * 1 + Vector3.new(0, 2, 0)
    local rayDirection = _direction.Unit * _distance

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { _hrp.Parent }
    params.IgnoreWater = true

    local result = workspace:Raycast(origin, rayDirection, params)

    if result and result.Instance and result.Instance.CanCollide then
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character and result.Instance:IsDescendantOf(player.Character) then
                result = nil
                break
            end
        end
        if result then return result.Instance end
    end

    -- Fallback: check small radius around origin
    local overlapParams = OverlapParams.new()
    overlapParams.FilterType = Enum.RaycastFilterType.Blacklist
    overlapParams.FilterDescendantsInstances = { _hrp.Parent }

    local nearbyParts = workspace:GetPartBoundsInRadius(origin, 2, overlapParams)
    for _, part in ipairs(nearbyParts) do
        if part.CanCollide then
            return part
        end
    end

    return nil
end


local function checkState(_hum)
    local state, type = true
    if not _hum or _hum.Health <= 0 then
        state, type = false, "Pathfinding: Character Died - Stopping"
    end
    return state, type
end

local stuckCheck = {
    lastPositions = {},
    requiredMoveDistance = 2.5,  -- studs to not be considered stuck
    timeThreshold = 1.2,         -- seconds without moving requiredDistance
    sampleInterval = 0.3         -- how often to check position
}

local function CheckStuck(hrp)
    if not hrp then return false end
    
    local currentTime = os.clock()
    local currentPos = hrp.Position
    
    -- Initialize or clean old positions
    if not stuckCheck.lastPositions[hrp] then
        stuckCheck.lastPositions[hrp] = {
            position = currentPos,
            time = currentTime
        }
        return false
    end
    
    local lastData = stuckCheck.lastPositions[hrp]
    local movedDistance = (currentPos - lastData.position).Magnitude
    
    -- If moved sufficiently, reset tracking
    if movedDistance > stuckCheck.requiredMoveDistance then
        lastData.position = currentPos
        lastData.time = currentTime
        return false
    end
    
    -- Check if we've been stuck for the time threshold
    if (currentTime - lastData.time) > stuckCheck.timeThreshold then
        -- Reset after reporting stuck
        lastData.position = currentPos
        lastData.time = currentTime
        return true
    end
    
    return false
end

local function getPath(_hrp, _target)
    local path = PathfindingService:CreatePath({
        AgentCanJump = true,
    })
    path:ComputeAsync(_hrp.Position, _target.Position)
    return path
end

local function MovePlayer(_hrp, _hum, _target, _dir)
    if not _hrp or not _hum or not _target then
        warn("Invalid parameters provided to MovePlayer")
        return false
    end

    -- Improved direction calculation
    local currentCFrame = _hrp.CFrame
    local directions = {
        target = (_target.Position - _hrp.Position).Unit,
        forward = currentCFrame.LookVector,
        left = -currentCFrame.RightVector,  -- More efficient than VectorToWorldSpace
        right = currentCFrame.RightVector,
        up = Vector3.new(0, 1, 0)
    }
    _dir = _dir or directions.forward

    -- Pathfinding attempt (keep your existing logic)
    local path = getPath(_hrp, _target)
    if path and path.Status == Enum.PathStatus.Success then
    for _, waypoint in pairs(path:GetWaypoints()) do
        -- Handle jumping waypoints
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            _hum.Jump = true
            task.wait(0.15) -- Small delay for jump to initiate
        end
        
        -- Start movement
        _hum:MoveTo(waypoint.Position)
        
        -- Movement monitoring
        local moveStart = os.clock()
        local lastCheckPos = _hrp.Position
        
        while not _hum.MoveToFinished:Wait(0.1) do -- Check every 0.1 seconds
            -- Enhanced stuck detection during movement
            if CheckStuck(_hrp) then
                print("Detected stuck - attempting recovery")
                _hum.Jump = true
                -- Try moving diagonally up/right
                _hum:MoveTo(_hrp.Position + directions.right * 6 + directions.up * 2)
                break -- Exit this waypoint and move to next
            end
            
            -- Additional state check
            local state, reason = checkState(_hum)
            if not state then 
                print("Movement interrupted:", reason)
                break
            end
            
            -- Early exit if close to waypoint
            if (_hrp.Position - waypoint.Position).Magnitude < 3 then
                break
            end
        end
        
        -- Final state check before next waypoint
        local state, reason = checkState(_hum)
        if not state then 
            print("Cannot continue:", reason)
            break 
        end
    end
    else
        -- Improved fallback movement with smarter direction selection
        if CheckStuck() then
            _hum.Jump = true
            _hum:MoveTo(_hrp.Position + directions.right * 5 + directions.up * 1.5)
            task.wait(0.3)
        end

        -- Check all potential directions
        local forwardClear = not checkForWall(_hrp, directions.forward, 10)
        local targetClear = not checkForWall(_hrp, directions.target, math.min(100, (_target.Position - _hrp.Position).Magnitude))
        local leftClear = not checkForWall(_hrp, directions.left, 8)
        local rightClear = not checkForWall(_hrp, directions.right, 8)

        -- Priority-based movement
        if targetClear and (_target.Position - _hrp.Position).Magnitude > 5 then
            _hum:MoveTo(_hrp.Position + directions.target * 10)
        elseif forwardClear then
            _hum:MoveTo(_hrp.Position + directions.forward * 10)
        elseif leftClear and not rightClear then
            _hum:MoveTo(_hrp.Position + directions.left * 8)
        elseif rightClear and not leftClear then
            _hum:MoveTo(_hrp.Position + directions.right * 8)
        elseif leftClear and rightClear then
            -- If both sides clear, pick one randomly to prevent zig-zag
            if math.random() > 0.5 then
                _hum:MoveTo(_hrp.Position + directions.left * 8)
            else
                _hum:MoveTo(_hrp.Position + directions.right * 8)
            end
        else
            -- Completely stuck - jump back
            _hum.Jump = true
            _hum:MoveTo(_hrp.Position + (-directions.forward * 5) + directions.up * 2)
        end
    end
    return true
end

local function UpdateDynamicPath(pathInstance, playerPosition)
    local waypoints = pathInstance:GetWaypoints()
    local thresholdSq = 9  -- 3 studs squared
    local firstUnreached = 1
    
    for i = 1, #waypoints do
        local delta = waypoints[i].Position - playerPosition
        local distanceSq = delta.X * delta.X + delta.Y * delta.Y + delta.Z * delta.Z
        
        if distanceSq <= thresholdSq then
            firstUnreached = i + 1
        else
            break
        end
    end
    
    return {unpack(waypoints, firstUnreached)}
end

-- Visual drawer (modified)
local function DrawPath(waypoints, _folder)
    cleanFolder(_folder)
    for i = 3, #waypoints do -- DOESNT SHOW THE 2 POINTS IN / BEHIND CHARACTER
        local waypoint = waypoints[i]
        local part = Instance.new("Part")
        part.Shape = Enum.PartType.Ball
        part.Size = Vector3.new(1.5, 1.5, 1.5)
        part.Position = waypoint.Position + Vector3.new(0, 2, 0)
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.new(0, 1, 0)
        part.Parent = _folder
    end
end

-- Main path handler (FIXED)
local pathConnection = {}
local pathFolders = {}

getgenv().ShowPath = function(_target, _toggle)
    if not _target or not _target:IsA("BasePart") then print("Nil or not part") return end
    if not _toggle then 
        if pathConnection[_target] then
            pathConnection[_target]:Disconnect() pathConnection[_target] = nil
        end
        removeFolder(pathFolders[_target])
        print("ShowPath:", _target, "Removed")
        return
    end

    local folder = Instance.new("Folder")
    folder.Parent = rootFolder
    folder.Name = _target.Name
    pathFolders[_target] = folder

    pathConnection[_target] = RunService.Heartbeat:Connect(function()
        local hrp = Player.Character:WaitForChild("HumanoidRootPart", 1)
        local humanoid = Player.Character:WaitForChild("Humanoid", 1)
        if hrp and humanoid then
            if WithinPart(_target) then
                pathConnection[_target]:Disconnect() pathConnection[_target] = nil
                removeFolder(pathFolders[_target])
                print("Show Path Finished")
                return
            end

            local path = PathfindingService:CreatePath()
            path:ComputeAsync(hrp.Position + hrp.CFrame.LookVector, _target.Position)
            if path.Status == Enum.PathStatus.Success and pathConnection[_target] then
                --local remainingPath = UpdateDynamicPath(path, hrp.Position)
                DrawPath(path:GetWaypoints(), pathFolders[_target])
            end
        else 
            cleanFolder(pathFolders[_target])
        end
    end)
end

getgenv().Clean = function(_folder)
    _folder = _folder or Workspace
    for _, modifier in pairs(_folder:GetDescendants()) do
        if modifier:IsA("PathfindingModifier") then
            modifier:Destroy()
        end
    end
end


getgenv().PathFind = function(_target)

    local inputCon

    if not _target or not _target:IsA("BasePart") then warn("PathFind: Target Nil or isnt a Part") return end
    local hrp = Player.Character:WaitForChild("HumanoidRootPart")
    local hum = Player.Character:WaitForChild("Humanoid")

    local dir = hrp.CFrame.LookVector

    if PFisRunning then
        PFisRunning = false
        print("ALREADY RUNNING, STOPPING")
        return
    end

    
    PFisRunning = true
    local status = true
    inputCon = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.Keyboard then
            print("Pathfinding: Player Took Control - Stopping")
            status = false
            inputCon:Disconnect()
            return
        end
    end)

    while status and not WithinPart(_target) and PFisRunning do
        local state, type = checkState(hum)
        if not state then print(type) break end
        if not MovePlayer(hrp, hum, _target, dir) then 
            -- CHANGE DIR
            print("Changing Direction")
            dir = hrp.CFrame:VectorToWorldSpace(Vector3.new(-1, 0, 0))
        end
        task.wait()
    end

    --Close Connections / Events
    inputCon:Disconnect()
    print("Pathfinding: Finished")
    PFisRunning = false
end

print("Pathfinding: Loaded")
