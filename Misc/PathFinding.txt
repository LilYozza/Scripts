local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer



local function checkForWall(_hrp, _direction, _distance)
    _direction = _direction or _hrp.CFrame.LookVector
    _distance = _distance or 10
    local origin = _hrp.Position + _hrp.CFrame.LookVector * 1 + Vector3.new(0, 2, 0)  -- raise ray a bit to avoid ground
    local rayDirection = _direction.Unit * _distance

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { _hrp.Parent } -- exclude self character
    params.IgnoreWater = true

    local result = workspace:Raycast(origin, rayDirection, params)

    if result and result.Instance and result.Instance.CanCollide then
        -- Exclude player characters
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character and result.Instance:IsDescendantOf(player.Character) then
                return nil
            end
        end
        return result.Instance
    end

    return nil
end


local function checkState(_hum)
    local state, type = true
    if not _hum or _hum.Health <= 0 then
        state, type = false, "Pathfinding: Character Died - Stopping"
    end
    return state, type
end

local function getPath(_hrp, _target)
    local path = PathfindingService:CreatePath()
    path:ComputeAsync(_hrp.Position, _target.Position)
    return path
end

local function MovePlayer(_hrp, _hum, _target, _dir)

     local directions = {
        forward = _hrp.CFrame.LookVector,
        left = _hrp.CFrame:VectorToWorldSpace(Vector3.new(-1, 0, 0)),
        right = _hrp.CFrame:VectorToWorldSpace(Vector3.new(1, 0, 0))
    }   

    _dir = _dir or _hrp.CFrame.LookVector
    local path = getPath(_hrp, _target)
    if path.Status == Enum.PathStatus.Success then
        print("Path Found")
        for _, waypoint in pairs(path:GetWaypoints()) do
            if waypoint.Action == Enum.PathWaypointAction.Jump then
                _hum.Jump = true
            end
            _hum:MoveTo(waypoint.Position)

            local state, type = checkState(_hum)
            if not state then print(type) break end
            
            _hum.MoveToFinished:Wait()
        end
    else
        --METHOD OF FINDING PATH
        print("Path Not Found")

        local ch = checkForWall(_hrp, directions.forward, 10)
        if ch then 
            --print("Ran into:", ch.Name)
            local ch2 = checkForWall(_hrp, directions.left, 10)
            if ch2 then
                -- go right
                
                local b = math.random(0, 1) == 1
                if b then
                    print("Left is Blocked, Going right")
                    _hum:MoveTo(_hrp.Position + directions.right * 10)
                else
                    print("Left is Blocked, Going To Target")
                    _hum:MoveTo(_hrp.Position + (_target.Position - _hrp.Position).Unit * 10)
                end
            else
                -- go left
                
                local b = math.random(0, 1) == 1
                if b then
                    print("Right is Blocked, Going Left")
                    _hum:MoveTo(_hrp.Position + directions.left * 10)
                else
                    print("Left is Blocked, Going To Target")
                    _hum:MoveTo(_hrp.Position + (_target.Position - _hrp.Position).Unit * 10)
                end
            end



            _hum.MoveToFinished:Wait(1)
            return false
        else
            _hum:MoveTo(_hrp.Position + _hrp.CFrame.LookVector * 10)
        end
    end
    return true
end





getgenv().PathFind = function(_target)

    local inputCon

    if not _target or not _target:IsA("BasePart") then warn("PathFind: Target Nil or isnt a Part") return end
    local hrp = Player.Character:WaitForChild("HumanoidRootPart")
    local hum = Player.Character:WaitForChild("Humanoid")

    local dir = hrp.CFrame.LookVector

    if getgenv().PFisRunning then
        getgenv().PFisRunning = false
        print("ALREADY RUNNING, STOPPING")
    end

    
    getgenv().PFisRunning = true
    local status = true
    inputCon = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.Keyboard then
            print("Pathfinding: Player Took Control - Stopping")
            status = false
            inputCon:Disconnect()
            return
        end
    end)

    while status and (hrp.Position - _target.Position).Magnitude > 4 and getgenv().PFisRunning do
        local state, type = checkState(hum)
        if not state then print(type) break end
        if not MovePlayer(hrp, hum, _target, dir) then 
            -- CHANGE DIR
            print("Changing Direction")
            dir = hrp.CFrame:VectorToWorldSpace(Vector3.new(-1, 0, 0))
        end
        task.wait()
    end

    --Close Connections / Events
    inputCon:Disconnect()
    print("Pathfinding: Finished")
    getgenv().PFisRunning = false
end

print("Pathfinding: Loaded")
