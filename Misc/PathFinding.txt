local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local function cleanFolder(_folder)
    for _,v in pairs(_folder:GetChildren())do
        v:Destroy()
    end
    return _folder
end

local function checkForWall(_hrp, _direction, _distance)
    _direction = _direction or _hrp.CFrame.LookVector
    _distance = _distance or 10
    local origin = _hrp.Position + _hrp.CFrame.LookVector * 1 + Vector3.new(0, 2, 0)
    local rayDirection = _direction.Unit * _distance

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { _hrp.Parent }
    params.IgnoreWater = true

    local result = workspace:Raycast(origin, rayDirection, params)

    if result and result.Instance and result.Instance.CanCollide then
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character and result.Instance:IsDescendantOf(player.Character) then
                result = nil
                break
            end
        end
        if result then return result.Instance end
    end

    -- Fallback: check small radius around origin
    local overlapParams = OverlapParams.new()
    overlapParams.FilterType = Enum.RaycastFilterType.Blacklist
    overlapParams.FilterDescendantsInstances = { _hrp.Parent }

    local nearbyParts = workspace:GetPartBoundsInRadius(origin, 2, overlapParams)
    for _, part in ipairs(nearbyParts) do
        if part.CanCollide then
            return part
        end
    end

    return nil
end


local function checkState(_hum)
    local state, type = true
    if not _hum or _hum.Health <= 0 then
        state, type = false, "Pathfinding: Character Died - Stopping"
    end
    return state, type
end

local function getPath(_hrp, _target)
    local path = PathfindingService:CreatePath({
        AgentCanJump = true,
    })
    path:ComputeAsync(_hrp.Position, _target.Position)
    return path
end

local function MovePlayer(_hrp, _hum, _target, _dir)

     local directions = {
        target = (_target.Position - _hrp.Position).Unit,
        forward = _hrp.CFrame.LookVector,
        left = _hrp.CFrame:VectorToWorldSpace(Vector3.new(-1, 0, 0)),
        right = _hrp.CFrame:VectorToWorldSpace(Vector3.new(1, 0, 0))
    }   

    _dir = _dir or _hrp.CFrame.LookVector
    local path = getPath(_hrp, _target)
    if path.Status == Enum.PathStatus.Success then
        print("Path Found")
        for _, waypoint in pairs(path:GetWaypoints()) do
            if waypoint.Action == Enum.PathWaypointAction.Jump then
                _hum.Jump = true
            end
            _hum:MoveTo(waypoint.Position)

            local state, type = checkState(_hum)
            if not state then print(type) break end
            
            _hum.MoveToFinished:Wait()
        end
    else
        --METHOD OF FINDING PATH
        --print("Path Not Found")

        local ch = checkForWall(_hrp, directions.forward, 10)
        if ch then 
            --print("Ran into:", ch.Name)
            local ch2 = checkForWall(_hrp, directions.target, 100)
            if not ch2 then
                print("Going To Target")
                _hum:MoveTo(_hrp.Position + (_target.Position - _hrp.Position).Unit * 10)
            else
                local ch3 = checkForWall(_hrp, directions.left, 10)
                if ch3 then
                    print("Left is Blocked, Going right")
                    _hum:MoveTo(_hrp.Position + directions.right * 10)
                else
                print("Right is Blocked, Going Left")
                _hum:MoveTo(_hrp.Position + directions.left * 10)
                end
            end
            _hum.MoveToFinished:Wait(1)
            return false
        else
            _hum:MoveTo(_hrp.Position + _hrp.CFrame.LookVector * 10)
        end
    end
    return true
end

local function UpdateDynamicPath(pathInstance, playerPosition)
    local waypoints = pathInstance:GetWaypoints()
    local thresholdSq = 9  -- 3 studs squared
    local firstUnreached = 1
    
    for i = 1, #waypoints do
        local delta = waypoints[i].Position - playerPosition
        local distanceSq = delta.X * delta.X + delta.Y * delta.Y + delta.Z * delta.Z
        
        if distanceSq <= thresholdSq then
            firstUnreached = i + 1
        else
            break
        end
    end
    
    return {unpack(waypoints, firstUnreached)}
end

-- Visual drawer (modified)
local function DrawPath(waypoints)
    if script:FindFirstChild("PathVisuals") then
        script.PathVisuals:Destroy()
    end

    local folder = Workspace:FindFirstChild("PathVisuals")
    if not folder then
        folder = Instance.new("Folder")
        folder.Name = "PathVisuals"
        folder.Parent = workspace -- CRUCIAL CHANGE: Parent to workspace instead of script
    else cleanFolder(folder) end



    for _, waypoint in pairs(waypoints) do
        local part = Instance.new("Part")
        part.Shape = Enum.PartType.Ball
        part.Size = Vector3.new(1.5, 1.5, 1.5)
        part.Position = waypoint.Position + Vector3.new(0, 2, 0) -- Raise above ground
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.new(0, 1, 0)
        part.Parent = folder
    end
end

-- Main path handler (FIXED)
local pathConnection
getgenv().ShowPath = function(_target, _toggle)
    if not _target or not _target:IsA("BasePart") then print("Nil or not part") return end
    if not _toggle then 
        pathConnection:Disconnect()
        print("Removed") -- TEMP FEATURE
        task.wait(0.5)
        local folder = Workspace:FindFirstChild("PathVisuals")
        cleanFolder(folder)
        return
    end

    local hrp = Player.Character:WaitForChild("HumanoidRootPart")
    local humanoid = Player.Character:WaitForChild("Humanoid")


    pathConnection = game:GetService("RunService").Heartbeat:Connect(function()
        local path = PathfindingService:CreatePath()
        path:ComputeAsync(hrp.Position + hrp.CFrame.LookVector, _target.Position)
        if path.Status == Enum.PathStatus.Success then
            --local remainingPath = UpdateDynamicPath(path, hrp.Position)
            DrawPath(path:GetWaypoints())
        else
            warn("Path blocked!")
        end


        if (hrp.Position - _target.Position).Magnitude < 4 then
            pathConnection[#pathConnection]:Disconnect()
            print("Show Path Finished")
            return
        end

    end)
end




getgenv().PathFind = function(_target)

    local inputCon

    if not _target or not _target:IsA("BasePart") then warn("PathFind: Target Nil or isnt a Part") return end
    local hrp = Player.Character:WaitForChild("HumanoidRootPart")
    local hum = Player.Character:WaitForChild("Humanoid")

    local dir = hrp.CFrame.LookVector

    if getgenv().PFisRunning then
        getgenv().PFisRunning = false
        print("ALREADY RUNNING, STOPPING")
    end

    
    getgenv().PFisRunning = true
    local status = true
    inputCon = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.Keyboard then
            print("Pathfinding: Player Took Control - Stopping")
            status = false
            inputCon:Disconnect()
            return
        end
    end)

    while status and (hrp.Position - _target.Position).Magnitude > 4 and getgenv().PFisRunning do
        local state, type = checkState(hum)
        if not state then print(type) break end
        if not MovePlayer(hrp, hum, _target, dir) then 
            -- CHANGE DIR
            print("Changing Direction")
            dir = hrp.CFrame:VectorToWorldSpace(Vector3.new(-1, 0, 0))
        end
        task.wait()
    end

    --Close Connections / Events
    inputCon:Disconnect()
    print("Pathfinding: Finished")
    getgenv().PFisRunning = false
end

print("Pathfinding: Loaded")
