local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer





local function checkForWall(_hrp, direction)
    local origin = _hrp.Position + Vector3.new(0, 2, 0)  -- raise ray a bit to avoid ground
    local rayDirection = direction.Unit * 5

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { _hrp.Parent } -- exclude self character
    params.IgnoreWater = true

    local result = workspace:Raycast(origin, rayDirection, params)

    if result and result.Instance and result.Instance.CanCollide then
        -- Exclude player characters
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character and result.Instance:IsDescendantOf(player.Character) then
                return nil
            end
        end
        return result.Instance
    end

    return nil
end

local function moveUntilWall(_hrp, _hum, dirt, _dir)
    print("moveUntilWall")

        _hum:MoveTo(_hrp.Position + _dir * 5) -- for the first move
        _hum.MoveToFinished:Wait()

    while true do
        _hum:MoveTo(_hrp.Position + _hrp.CFrame.LookVector * 5)
        _hum.MoveToFinished:Wait()

        --break when wall
        if checkForWall(_hrp, dirt.forward) then break end

        task.wait()
    end
    print("Finished moveUntilWall")
    return
end

local function MovePlayerWithWallCheck(_hrp, _hum, _target)

    local directions = {
        forward = _hrp.CFrame.LookVector,
        left = _hrp.CFrame:VectorToWorldSpace(Vector3.new(-1, 0, 0)),
        right = _hrp.CFrame:VectorToWorldSpace(Vector3.new(1, 0, 0))
    }

    -- Move towards the target (front direction)
    local frontWall = checkForWall(_hrp, directions.forward)
    local leftWall = checkForWall(_hrp, directions.left)
    local rightWall = checkForWall(_hrp, directions.right)

    -- Check for walls and move accordingly
    if not frontWall then
        moveUntilWall(_hrp, _hum, directions, _hrp.Position + directions.forward * 10)
    elseif not leftWall then
        moveUntilWall(_hrp, _hum, directions, _hrp.Position + directions.left * 10)
    elseif not rightWall then
        moveUntilWall(_hrp, _hum, directions, _hrp.Position + directions.right * 10)
    else
        print("No path available, blocking on all sides.")
    end
    return
end

local function checkState(_hum)
    local state, type = true
    if not _hum or _hum.Health <= 0 then
        state, type = false, "Pathfinding: Character Died - Stopping"
    end
    return state, type
end

local function getPath(_hrp, _target)
    local path = PathfindingService:CreatePath()
    path:ComputeAsync(_hrp.Position, _target.Position)
    return path
end


local function MovePlayer(_hrp, _hum, _target)
    local path = getPath(_hrp, _target)
    if path.Status == Enum.PathStatus.Success then
        print("Path Found")
        for _, waypoint in pairs(path:GetWaypoints()) do
            if waypoint.Action == Enum.PathWaypointAction.Jump then
                _hum.Jump = true
            end
            print("Moving", _hum, waypoint.Position)
            _hum:MoveTo(waypoint.Position)
            _hum.MoveToFinished:Wait()
        end
    else
        --METHOD OF FINDING PATH
        print("Path Not Found")
        MovePlayerWithWallCheck(_hrp, _hum, _target)
    end
end


local inputCon
getgenv().PathFind = function(_target)
    if not _target or not _target:IsA("BasePart") then warn("PathFind: Target Nil or isnt a Part") return end
    local hrp = Player.Character:WaitForChild("HumanoidRootPart")
    local hum = Player.Character:WaitForChild("Humanoid")

    local status = true

    inputCon = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            print("Pathfinding: Player Took Control - Stopping")
            if inputCon then inputCon:Disconnect() end
            return
        end
    end)

    while status and (hrp.Position - _target.Position).Magnitude > 4 do
        local state, type = checkState(hum)
        if not state then print(type) break end
        MovePlayer(hrp, hum, _target)
        task.wait()
    end

    --Close Connections / Events
    if inputCon then inputCon:Disconnect() end
    print("Pathfinding: Finished")
end

print("Pathfinding: Loaded")
